import React from 'react';
import './About.scss';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faHeart as solidHeart } from '@fortawesome/free-solid-svg-icons';
import gallery from '../images/gallery.png';
import quiz from '../images/quiz.png';
import workspace from '../images/workspace.png';
import stylesheet from '../images/stylesheet.png';
import gmm from '../images/gmm.png';
import palette_center from '../images/palette_center.png';
import saturation_behavior from '../images/saturation_behavior.jpeg';
import saturation_proportion from '../images/saturation_proportion.png';
import lightness from '../images/lightness.png';
import hue from '../images/hue.png';
import Header from '../components/Header.js';

/**
 * About page is a README and describes the algorithm.
 */
class About extends React.Component {
    constructor(props) {
        super(props);

        this.state = {
            tab: "info",
        }

        this.goHome = this.goHome.bind(this);
    }

    toggleTab = (location) => {
        this.setState({tab: location});
    }

    goHome = () => {
        this.props.history.push("/");
    }

    render() {
        let tabcontent = <div className="tabs">
                            <div className="tabs__info" style={{color: '#62DDEE', backgroundColor: 'white'}}> INFO </div>
                            <div className="tabs__algorithm" onClick={() => this.toggleTab("algorithm")} style={{color: 'white', backgroundColor: '#62DDEE'}}> ALGORITHM </div>
                        </div>;

        let content = <> 
                            <h3> Hi! We're so happy you want to learn more about Gooey! <span role="img" aria-label="happy">üòä</span></h3>
                            <p> 
                                Gooey is a project that we cooked up in Spring 2020, for a CS0320: Software Engineering, a computer science
                                class offered at Brown University. Our inspiration came from the fact that two of our members were heavily 
                                interested in graphic design, but had yet to discover an application that streamlined the process of 
                                selecting colors and fonts, while also encouraging exploration.
                            </p>

                            <h4>How does Gooey work?</h4>

                            <h5>1) Sign up and make a workspace!</h5>
                            <p> 
                                You'll need to sign up to use Gooey (don't worry, it's easy)! Once you have an account, you can create a "workspace," a space that represents a single project you are working on.
                            </p>
                            <img src={workspace} alt="" />

                            <h5>2) Take the color quiz.</h5>
                            <p> 
                                When you create a workspace, you'll be redirected to a color quiz. You'll want to choose colors that represent the kind
                                of project you want. For example, if you are making a fairy princess poster, you'll want to pick a lot 
                                of pastel colors. Choosing colors representative of your project will help the algorithm give you recommendations 
                                that will align with what you want.
                            </p>
                            <img src={quiz} alt=""  />
                            <h5> 3) Explore your recommendations.</h5>
                            <p> 
                                Once you finish the quiz, you'll be redirected to your workspace. Here, you'll find two tabs: Gallery and Stylesheets.
                                The gallery contains immutable cards generated by the algorithm. If you don't like any of 
                                them, then you can refresh them infinitely! (Don't worry, this doesnt' get rid of the cards you already liked.) Liking cards will
                                help inform the algorithm of your preferences, so we recommend to like some cards before refreshing!
                            </p>
                            <img src={gallery}  alt="" />

                            <h5> 4) Make stylesheets.</h5>
                            <p> 
                                Finally, in the stylesheet page, you have the ability to play around with stylesheet cards. Our definition of a stylesheet 
                                card is a card that defines a palette and typography ‚Äî it represents a visual language for your project. You can convert
                                a favorited card from the gallery into the stylesheet or you can start from scratch. You'll have the ability to add up to 
                                5 colors in your palette, choose from 60 fonts, and share the card with your friends.
                            </p>

                            <img src={stylesheet} alt=""  />

                            <h4>How was Gooey developed?</h4>
                            <p> 
                                Gooey is developed with React frontend, Flask backend, Google's Cloud Firestore as the database, and is hosted on Heroku.
                            </p>
                      </>



        if (this.state.tab === "algorithm") {
            tabcontent = <div className="tabs">
                            <div className="tabs__info" onClick={() => this.toggleTab("info")} style={{color: 'white', backgroundColor: '#62DDEE'}}> INFO </div>
                            <div className="tabs__algorithm"  style={{color: '#62DDEE', backgroundColor: 'white'}}> ALGORITHM </div>
                        </div>;

            content = <>  <h3> Algorithm </h3>
                          <p>The color palette recommendation algorithm generates gallery cards based on colors the user likes from the color quiz, and improves its recommendations when the user begins to like gallery cards.</p>

                            <p>The algorithm can be split into 3 main parts: I. processing inputs, II. a <a href="https://scikit-learn.org/stable/modules/mixture.html">Gaussian mixture model (gmm)</a> for color clustering, and III. an interpolation function inspired by <a href="https://www.slynyrd.com/blog/2018/1/10/pixelblog-1-color-palettes">Slynyrd‚Äôs tutorial</a> on color ramps.</p> 

                            <h4>I. Processing Inputs </h4>

                            <p>Input processing 1) converts the given colors into a consistent color format and passes into color GMM 2) constructs a randomness index, and 3) constructs a Gaussian mixture model for hue shift preference. </p>

                            <h5>1) HSL CONVERSION </h5>
                            <ul>
                                <li> 
                                   Given a list of quiz colors that a user selects, and later, a list of palettes (tuples of colors) that the user likes from the gallery page, we convert all inputs into <a href="http://hslpicker.com/">HSL</a> (hue, saturation, lightness), the color space vital for the interpolation function. Hue is in the range 0-360 and it ‚Äúwraps around‚Äù (both ends of the spectrum are red). Saturation has the range 0-1, with 1 being the most saturated. Lightness also has the range 0-1, with 1 being the lightest.
                                </li>

                                <li>
                                    We extract the individual colors from all the liked palettes. Then, we compile them and all the selected quiz colors into an array, which is passed into part II of the algorithm.
                                </li>
                            </ul>

                            <h5>2) RANDOMIZATION INDEX </h5>
                            <ul>
                                <li>
                                    In order to prevent overfitting to the user selections and to allow for exploration in palette generation, we construct a randomness index between 0 and 1 based on the quantity of input data. This index represents the probability of arbitrary exploration when palettes are generated, and it is computed through an inverse function: 1/(0.04*q+1) where q is the total number of colors the user has demonstrated preference for. With 0 input color, this index is set to 1 (complete randomness), and it decreases as more colors are selected. When the number of selected colors surpass 25,the index is lesss than 0.5.
                                </li>
                            </ul>

                            <h5>3) CALCULATING HUE SHIFT </h5>
                            <ul>
                                <li>
                                    While saturation and lightness of the gallery card colors have constraints due to concerns regarding readability and friendly visual experience, the hues of the background and font colors are largely unconstrained. For example, it is all perfectly reasonable for a user to only like monochromatic cards or only cards composed of complementary colors or a mixture of both. Thus, we attempt to learn the kinds of palette hues the user likes by constructing a hue shift index from the hue difference between the 2 colors of each liked palette and fitting all of these indices with a gmm to be sampled from in part III of the algorithm. The numerical value of the hue shift index is between 0 and 1 and can be interpreted as a rough representation of the size of the hue shift between colors of a palette.
                                </li>
                                <li>
                                    While determining the exact construction of this index, we encountered difficulties as the visual perception of hues are not linearly correlated with the numerical values, and it is also inconsistent across the spectrum. We eventually settled on a negative absolute value function where a numerical hue difference of 180 is mapped to an index of 1 while 0 and 360 are mapped to 0 (recall that hues in the HSL space ‚Äúwrap around‚Äù). Although this function is not optimal, it does not unevenly ‚Äúfavors‚Äù certain ranges of hue differences (as for example, a sine function does), and the results we obtain from it are sufficiently satisfactory.
                                </li>
                                <li>
                                    Lastly, if we have more than 1 palette passed in, then we pass all the indices we created into a GMM. This allows the generator to learn more than 1 kind of hue preferences. For example, if a user likes both high contrast and low contrast, the generator can produce both kinds of palette. Otherwise, when there is insufficient data, the hue shift index is randomly generated.
                                </li>


                            </ul>


                            <h4>II. Gaussian Mixture Model: Clustering Similar Colors </h4>

                            <img src={gmm} alt=""  />

                            <p>
                            We 1) fit all the colors compiled from Part I Step 2 with a Gaussian mixture model and then 2) sample colors from the model.
                            </p>

                            <ul>
                                <li>
                                    The purpose of the GM is to gain insights on the colors the user likes so that the generated gallery cards would intelligently reflect the user‚Äôs preference. The model fits the array outputted from part I, which contains all the colors the user has demonstrated preference for, whether through quiz or gallery cards. The model is probabilistic and softly clusters on the color inputs, learning the colors the user likes while also allowing for reasonable deviations from the exact input.
                                </li>

                                <li>
                                    Next, we sample from the GMM to get a number of colors that would serve as the starting points for our palette generation. More precisely, they would be returned and passed into the interpolation function of part III. The colors sampled should match what the user has liked. For example, if a user likes a great quantity of red, more reds are likely to be generated when we sample from the GMM. This is also why we add in the randomness factor described in part I. While we want to match the user‚Äôs liking, we also do not want to be chained to the past user input, especially with few inputs.
                                </li>
                            </ul>



                            <h4>III. Interpolation Function: Stepping Wheel for Generating N-Colored Palettes </h4>

                            <p>
                                This part is arguably the most essential part of the algorithm -- it makes a palette for each color sampled from the gmm in part II. Although we only use 2 colors for gallery cards, the interpolation function actually generates palettes of any number of colors. For this application, we set the number of palette colors to be in the range [5, 8], and we take the colors at the ends of the outputted palette to be the background and font colors of the cards. We named the interpolation function "Stepping Wheel" as conceptually, it makes one step at a time from the inputted color to assemble a palette. The functionality of Stepping Wheel can be decomposed into 4 parts: 1) processing given color and setting parameters, 2) computing hues based on a linear model, 3) computing saturation based on a model that either behaves roughly like a square function or like a cubic function, and 4) computing lightness based on a logarithmic model.
                            </p>

                            <h5> 1) PROCESSING GIVEN COLORS AND SETTING PARAMETERS </h5>

                            <ul>
                                <li>
                                For each palette, we uniformally randomly select its number of colors from [5, 8] to enhance the variability and diversity of generated gallery cards. [5,8] was developed as a heuristic for a sufficient amount of contrast. Next, we make use of the randomness index established in Part I Step 3 to ‚Äúrandomize‚Äù the input color. We use the random() function of the <a href="https://docs.python.org/3/library/random.html">random library,</a> and if the returned value is less than the index, we add arbitrary values (which may be positive or negative) to the input color‚Äôs hsl values. 
                                </li>

                                <li>
                                    With the ‚Äúrandomized‚Äù color, we then use its lightness value to determine where this color would be in the final output palette with a modified sigmoid function that converts the lightness value into the index of the input color in the output palette array. This is to prevent the palette from becoming too bright or too dark. We use lightness as the determining factor because while hues and saturations ‚Äúwrap around‚Äù or ‚Äúbounce‚Äù towards both ends, it is more optimal if lightness does not have such a mechanism. Thus, the input lightness value has the greatest constraints on the resulting palette.
                                </li>

                                <li> 
                                    Notably, for colors that are medium dark (lightness in [0.3, 0.5]) or medium light (lightness in [0.65, 0.8]), occasionally the algorithm would alter what the given color feeds into the sigmoid function to enable these medium colors to be closer to the ends of the output palette. This increases the variability of cards generated and the chance that the cards‚Äô colors closely match the colors the user has liked.
                                </li>
                            </ul>

                            <img src={palette_center} alt="" />
                            <div className="caption">
                             This depicts the modified sigmoid function used to determine the placement of the sampled color for a palette of 6 colors. This shows how given lightness (x axis) is mapped to indices (y axis). Note that the y values are rounded in the actual implementation to get integer indices.
                            </div> 


                            <h5> 2) COMPUTING HUE </h5>

                            <ul> 
                                <li>
                                We designed the hues to follow a linear model. From the first color in the palette to the last, the values of their hues either decrease by a constant amount throughout or increase by a constant amount throughout. Values are modded so that it continuously reflects the change even when the numerical values go out of bounds (recall that hues ‚Äúwrap around‚Äù). Whether the model increases or decreases is set randomly, and we fix the given color at the index determined in step 1) and calculate the other colors in the palette relative to it.
                                </li>

                                <li>
                                The size of the hue shift is generated with the hue shift index gmm introduced in Part I Step 3. For every palette, we sample from the Gaussian mixture model to obtain an index. Next, to increase variability in the output cards while simultaneously reflecting hue characteristics of the input, we implemented the following mechanism to obtain a proportion. If the random() function of the random library gives a value less than the index, we sample from the uniform distribution starting at the index to 1; otherwise, we sample from the uniform distribution starting at 0 to the index. For example, if the index sampled from the gmm is 0.2, then it is much more likely that the proportion is from 0 to 0.2 than it is from 0.2 to 1, but either range is possible. 
                                </li>

                                <li>
                                Notably, for indices between 0.4 to 0.6 that represent a medium level of contrast between the 2 colors of a palette, we add in regulations to make the proportion to be more likely to be in the medium range in order to better reflect the ‚Äúmedium-ness‚Äù. If there is insufficient palette data passed in, we randomly generate a proportion between 0 and 1. Finally, this proportion is multiplied by the maximum hue shift that we set to be 0.2 to give the actual hue shift value used in the linear model.
                                </li>
                            </ul>
                                <img src={hue} alt="" />
                            <div className="caption">
                                Example of the same liked colors, but different palettes generated by the hue index. On the left, there is a mix of monochromatic and mixed hue palettes, resulting in more palettes that are a mix. In contrast, if a user likes only monochromatic palettes, the generator will output monochromatic palettes.
                            </div>

                            


                            <h5> 3) COMPUTING SATURATION </h5>
                            
                            <ul>
                                <li>
                                Saturation follows a model that either behaves roughly like a square function or a cubic function‚Äîthat is, changes are small close to the center and large away from the center, where center is the given color whose location is established in step 1). There are 4 possibilities for the model as it can either increase or decrease both to the left and right; thus it can look like x^2, -x^2, x^3, or -x^3, as shown below. Values are clipped to the effect that the saturation values essentially ‚Äúbounce‚Äù back and forth between 0 and 1 so that changes can continue to be reflected even when the values hit 0 or 1 at any step.
                                </li>
                            </ul>

                            <img src={saturation_behavior} alt="" />
                            <div className="caption">
                                The 4 possible behaviors of the saturation model
                            </div>

                            <ul>
                                <li>
                                The exact numerical change at each step of the palette is determined through a proportion of the maximum saturation shift that is set to be 0.2. It is implemented this way in order to allow us better control the maximum shift. This proportion is computed through a modified sigmoid function that maps the absolute value of a color‚Äôs index difference from the center to a value between 0.5 and 1, as shown in the image below. It never fully reaches 1 but can continue to increase towards both ends even when the palette gets exceedingly large. This proportion is multiplied by the maximum saturation shift to give the actual change at each step.
                                </li>
                            </ul>

                            <img src={saturation_proportion} alt="" />
                            <div className="caption">
                                The saturation proportion function that maps index
                                difference from the given color (x axis) to a proportion
                                of the maximum saturation shift (y axis)
                            </div>

                            <h5> 4) COMPUTING LIGHTNESS </h5>

                            <ul>
                                <li>
                                Lightness follows a logarithmic model (a*log(x)) where it always increases but gets flatter and flatter. This means that the end of a palette is always the lightest, but the difference between the lightness values of adjacent colors gets smaller and smaller towards the end of the palette. The a in the model is determined with the absolute value of an inverse function: |0.1/(x-0.5)|^0.2 where x is the lightness of the given color. In effect, this makes the change at each step greater when the center color‚Äôs lightness is close to 0.5 while if the center lightness is close to 0 or 1, the change at each step would be smaller. When x is close to 0.5, we manually set a. The reason for a variable a is to prevent the colors from reaching maximum or minimum brightness too fast as unlike for hue and saturation, we cap lightness at a maximum and minimum to prevent it from going out of bounds.
                                </li>

                                <li>
                                This logarithmic model is implemented through change at each step in order to better control the shift, and this is done through the derivative of the log function, the inverse function a/x. The given color‚Äôs location is set to be the center, and we subtract towards the beginning of the palette and add towards the end of the palette. We add in regulations so that the magnitude of the change is not too extreme at both ends: at each step, 0.05*(a/x)^0.5 is added or subtracted where 0.05 can be interpreted as delta x.

                                </li>
                            </ul>

                            <img style={{width: "400px"}} src={lightness} alt="" />
                            <div className="caption">
                                The lightness model (blue) for a given lightness of 0.48, which is steeper around 0.48 and the lightness model (red) for a given lightness of 0.9, which is flatter around 0.9.
                            </div>

                            <h4> Thanks for reading! <span role="img" aria-label="chart">üìà</span></h4>

                            <p> Thanks for getting through this ~very~ long description! We hope you learned something. If you're curious, feel free to check out our <a href="https://github.com/artset/color_algo">prototyping code</a> for the algorithm, which includes 3 iterations. </p>
                      </>


        }
        return (
            <div className="about">

                <div className="overlay"></div>
                <Header text="home" type="generic" rerouteDashboard={this.goHome} />
                <div className ="about__content">
                

                    {tabcontent}

                    <div className="tab-description">

                        {content}


                        <div class="footer">
                            <p>Made with <FontAwesomeIcon icon={solidHeart} color={"#ff8f66"}/> by Katherine Sang, Minna Kimura-Thollander, Anna Wei, and YJ Kim. </p>

                            <p>Special thanks to the CS department's very own <a href="https://cs.brown.edu/~tbn/">Tim Nelson</a>, <a href="https://dritchie.github.io/">Daniel Ritchie</a>, 
                                and <a href="https://jeffhuang.com">Jeff Huang</a>, our advisory TAs Daphne Li-Chen and Jeffrey Zhu, and user testing provided by Amy Pu, Stefan Korfmacher, Julie Wang, and Rachel Sang! </p>
                            </div>
                        </div>
                </div>
            </div>
        );
    }
}

export default About;
